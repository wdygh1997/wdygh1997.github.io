---
title: 枚举
---

# 枚举

<script type="text/javascript" src="/include/head.js"></script>

枚举是指穷举解空间树的所有结点，找到满足条件的结点，枚举一般通过递归或者递推实现，当确定后续结点不满足条件时，可以剪枝或者限界减少枚举数量

## 枚举问题的分类

按照问题解空间的规模，枚举问题可以分为以下三类：

1、规模为幂级别$n^k$：递推实现

2、规模为指数级别$2^n$：递归实现

3、规模为排列级别$n!$：递归实现

## 幂级别枚举

通过递推（也就是循环）实现，$n^k$规模需要用k重循环遍历

## 指数级别枚举

通过递归实现，指数级别的递归是针对“选不选”的情况

```
void search(int x) {
    if (x到达递归边界) {
        // 得到一个解，进行处理
        return;
    }
    if (x满足剪枝条件) return;

    if (不选x未达递归边界 && 未满剪枝条件) {
        // 不选x，更新状态
        search(y); // 不选x的分支，进入y选不选的问题（假设x后继是y）
        // 还原现场
    }

    if (要选x未达递归边界 && 未满剪枝条件) {
        // 要选x，更新状态
        search(y); // 要选x的分支，进入y选不选的问题（假设x后继是y）
        // 还原现场
    }
}
```

## 排列级别枚举

通过递归实现，排列级别的递归是针对“选哪个”的情况

```
void search(int x) {
    if (x到达递归边界) {
        // 得到一个解，进行处理
        return;
    }
    if (x满足剪枝条件) return;

    for (遍历x号位的所有可能的选择i) {
        if (x选i到达递归边界) {
            // 得到一条到边界的路径，进行处理
            continue;
        }
        if (x选i满足剪枝条件) continue;

        // x号位选中i，更新状态
        search(y); // 进入y号位选哪个的问题（假设x后继是y）
        // 还原现场
    }
}
```

注解：

(1)一般的递归都可以归结为“选不选”和“选哪个”两种问题中的一种，当然也有两种综合起来，就是既有n种选择中“选哪个”的问题，又有“选不选”的问题，一种n+1种可能

```
void search(int x) {
    if (递归边界) {
        // 得到一个解，进行处理
        return;
    }
    if (剪枝条件) return;

    if (不选x未达递归边界 && 未满剪枝条件) {
        // 不选x，更新状态
        search(y); // n种可能x全部不选的分支，进入y选不选、选哪个的问题（假设x后继是y）
        // 还原现场
    }

    for (遍历x号位的所有可能的选择i) { // n种可能x要选一种的分支
        if (x选i到达递归边界) {
            // 得到一条到边界的路径，进行处理
            continue;
        }
        if (x选i满足剪枝条件) continue;

        // x号位选中i，更新状态
        search(y); // 进入y选不选、选哪个的问题（假设x后继是y）
        // 还原现场
    }
}
```

(2)指数级别枚举的解空间树是一棵根结点无意义的二叉树，排列级别枚举的解空间树是一棵根结点无意义的树（后继数不定且可能多于两个）

(3)递归有两种剪枝位置，一种是剪枝自身（在函数的开头），一种是剪枝后继（扩展后继之后），两种剪枝本质上没有区别，剪枝后继比剪枝自身的优点是，剪枝后继时还可以看到前驱结点，如果要利用前驱结点的信息进行剪枝，就必须使用剪枝后继（剪枝有时候两种都要用上）

(4)两种递归边界，如果是在函数的开头，递归会进入空指针（即x已经在边界之外），如果是扩展后继之后，递归不会进入空指针（y不会到边界之外），根据具体情况选择

(5)指数/排列枚举的解空间树的根结点是一个无意义的空结点，其子结点表示开头位的若干选择，不需要对根结点进行访问和操作

并且每个后继表示前驱的若干个选择，对后继进行操作时有时需要用到前驱的信息

根据上面两点原因，这里对结点进行访问和操作都是在扩展后继之后，关于进行访问和操作的两种位置及其区别可以参考<a href="https://www.dywan.xyz/note/202103/150001">深度优先搜索</a>

---

<script type="text/javascript" src="/include/tail.js"></script>
