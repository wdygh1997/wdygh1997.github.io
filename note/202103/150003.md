---
title: 枚举
---

# 枚举

<script type="text/javascript" src="/include/head.js"></script>

枚举也称暴力搜索，指的是穷举所有可能情况，从而达到求解的目的。枚举法非常通用，缺点是算法的冗余比较多。

我们这里引入两个概念：数据空间和状态空间。数据空间是欧氏空间还是非欧空间取决于数据的结构，状态空间是欧氏空间还是非欧空间取决于算法的架构。数据空间是否是欧氏空间与状态空间是否是欧氏空间没有必然联系，即使数据空间是同种类型，如果采用不同的算法，状态空间也有可能是不同类型的。

对数据空间的遍历可以在数据结构章节找到，这里主要介绍的是对状态空间的枚举。

对于枚举题来说，数据空间由题目给定，而状态空间由算法生成，所以设计算法时最重要的是要考虑，状态的定义是什么，状态之间如何转移。

$$
枚举状态空间
\left\{
\begin{aligned}
&欧氏状态空间（线性空间）\Rightarrow循环 \\
&\text{非欧状态空间（树型结构）}
\left\{
\begin{aligned}
&递归
\left\{
\begin{aligned}
&自顶向下（先序访问）\\
&自底向上（后序访问）\\
&（DFS：先序访问和后序访问二选一）\\
&（回溯法：先序位置更新状态，后序位置还原现场）
\end{aligned}
\right.
\\
&循环
\left\{
\begin{aligned}
&自顶向下（BFS）\\
&自底向上（递推法）
\end{aligned}
\right.
\end{aligned}
\right.
\end{aligned}
\right.
$$

## 在欧氏空间中的枚举

如果状态空间是欧氏空间（线性空间），直接通过循环就可以实现，n维欧式空间中的点只需要通过n重循环就可以枚举到。

## 在非欧空间中的枚举

如果状态空间是非欧空间（树型结构），可以通过递归和循环实现。

递归中，如果自顶向下就是先序访问，如果自底向上就是后序访问（DFS是先序访问和后序访问二选一，回溯法是在先序位置尝试更新状态，然后在后序位置还原现场）；循环中，如果自顶向下就是BFS，如果是自底向上就是递推法。

对于数据空间的遍历和对于状态空间的枚举，都可以采用自顶向下的方法或者自底向上的方法。

## 枚举的代码框架

欧氏状态空间的循环枚举比较简单，算法框架就是多重循环，对于不再必要的枚举可以采用break/continue机制跳过。

非欧状态空间的DFS和BFS详见<a href="https://www.dywan.xyz/note/202103/150001">深度优先搜索</a>和<a href="https://www.dywan.xyz/note/202103/150002">宽度优先搜索</a>，这里不再赘述。

### 递推法

非欧状态空间的递推法采用循环实现，关键在于得到递推关系，即对于某子结点来说，它往哪个父结点去，对于某父结点来说，它从哪些子结点来。

### 回溯法

非欧状态空间的回溯法采用递归实现，根据尝试访问的位置的不同，可以分为两种。

1、尝试访问自身：

```
void search(int x) {
    if (x到达递归边界) {
        // 得到一条到边界的路径（意味着得到一个解），进行处理
        return;
    }
    if (x满足剪枝条件) return;

    // 尝试x，更新状态

    for (遍历x的所有可能后继y) {
        if (y到达递归边界) {
            // 得到一条到边界的路径（意味着得到一个解），进行处理
            continue;
        }
        if (y满足剪枝条件) continue;

        search(y); // 进入尝试y的哪个后继的问题
    }

    // 还原现场
}

search(s); // 调用search，s为状态空间根结点
```

2、尝试访问后继：

```
void search(int x) {
    if (x到达递归边界) {
        // 得到一条到边界的路径（意味着得到一个解），进行处理
        return;
    }
    if (x满足剪枝条件) return;

    for (遍历x的所有可能后继y) {
        if (y到达递归边界) {
            // 得到一条到边界的路径（意味着得到一个解），进行处理
            continue;
        }
        if (y满足剪枝条件) continue;

        // 尝试y，更新状态
        search(y); // 进入尝试y的哪个后继的问题
        // 还原现场
    }
}

// 在此处尝试s，更新状态
DFS(s); // 调用search，s为状态空间根结点
// 还原现场
```

注解：递归算法框架中，判断剪枝条件、判断递归边界、进行访问操作都有两种位置，总结起来区别就是，在扩展后继之前的剪枝条件/递归边界/访问操作是针对自身的，在扩展后继之后的剪枝条件/递归边界/访问操作是针对后继的：

(1)对于访问操作的两种位置，如果采用针对后继的访问操作，在整个递归过程中是访问不到根结点的，如果需要访问根结点只能在递归外部进行，而采用针对自身的访问操作，在递归过程中能够访问到根结点。不过如果状态空间是森林型结构，构造一个无意义结点作为几个树型结构的父结点，那么整个状态空间就变成了一个树型结构，并且不需要访问根结点，则采用针对后继的访问操作更为方便。

(2)剪枝条件有两种位置，剪枝后继比剪枝自身的优点是，剪枝后继时还可以看到前驱结点，如果要利用前驱结点的信息进行剪枝，就必须使用剪枝后继。

(3)递归边界有两种位置，如果是在扩展后继之前，递归会进入空指针（即x已经在边界之外），如果是在扩展后继之后，递归不会进入空指针（y不会到边界之外）。

---

<script type="text/javascript" src="/include/tail.js"></script>
