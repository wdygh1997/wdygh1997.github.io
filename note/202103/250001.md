---
title: 多重背包
---

# 多重背包

<script type="text/javascript" src="/include/head.js"></script>

现有n件物品，物品i的个数为s[i]，物品i的体积为v[i]，物品i的价值为w[i]，要装入容量为m的背包中，求背包可装入的最大价值

## 动态规划设计

用集合的方法分析动态规划，动态规划所要求解的是大集合的属性，大集合可以通过划分成为若干较小集合，以此类推缩小到原子集合，原子集合属性就可以直接得出

动态规划需要定义状态表示，即集合的定义、要求解的集合属性的定义

动态规划需要推导状态计算，即大集合的划分方法、原子集合的属性值

### 状态表示

多重背包问题的集合及其属性定义如下

$$
\left\{
\begin{aligned}
&\text{集合}:\text{在前i个物品中选，体积和}\leqslant j\text{的所有选法集合}\\
&\text{属性}:f(i, j)\text{记录集合中所有选法的最大价值这一属性}
\end{aligned}
\right.
$$

最终要求解的是$f(n, m)$

### 状态计算

多重背包问题的原子集合（在前i个物品中选、体积和$\leqslant 0$的所有选法）的属性值可以直接得出为0

大集合i通过物品i的选不选、选多少划分为小集合i-1，以此类推可以缩小到原子集合

$$
f(i, j) = max
\left\{
\begin{aligned}
&f(i-1, j)&&\text{(不选物品i)}\\
&f(i-1, j-k*v[i])+k*w[i]&&\text{(选k个物品i)}
\end{aligned}
\right.
$$

其中，$i-1 \geqslant 0$、$j-k*v[i] \geqslant 0$、$k \leqslant s[i]$

## 滚动数组实现

大集合i只会划分为小集合i-1，因此可以将数组f由二维简化为一维，每轮循环中，f数组更新前存储的是小集合i-1属性，更新后存储的是大集合i属性

f[j]表示体积和$\leqslant j$的所有选法的最大价值，初始化为全0

```
for (int i = 0; i < n; i++)
    for (int j = m; j >= 0; j--)
        for (int k = 1; k <= s[i] && k*v[i] <= j; k++)
            f[j] = max(f[j], f[j - k*v[i]] + k*w[i]);
```

j从大到小循环，可以确保f[j - k*v[i]]是未更新前的值，是小集合i-1的属性

## 倍增思想优化

根据<a href="https://www.dywan.xyz/note/202103/290002">倍增</a>思想，对数量为si的每件原物品生成等价于$2^0$、...、$2^k$、$si-2^k$个原物品的新物品若干个（k是满足$2^k \leqslant si$的最大k），新物品可以组合成[0, si]内所有整数个原物品，从而替代原物品，并且数量会更少

cnt统计n件每件si个的原物品全部生成等价的每件1个的新物品之后新物品的件数，初始化为0

对每件原物品进行如下操作转化为新物品，同时统计新物品件数

```
for (int j = 1; j <= si; j *= 2) {
    si -= j;
    v[cnt] = j * vi;
    w[cnt] = j * wi;
    cnt++;
}
if (si > 0) {
    v[cnt] = si * vi;
    w[cnt] = si * wi;
    cnt++;
}
```

n件物品每件si个的多重背包问题转化为cnt件物品每件1个的0/1背包问题

```
for (int i = 0; i < cnt; i++)
    for (int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```

---

<script type="text/javascript" src="/include/tail.js"></script>
