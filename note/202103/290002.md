---
title: 倍增
---

# 倍增

<script type="text/javascript" src="/include/head.js"></script>

## 单个整数划分

## 区间整数划分

### 倍增思想优化

根据<a href="https://www.dywan.xyz/note/202103/290002">倍增</a>思想，对数量为si的每件原物品生成等价于$2^0$、......、$2^k$、si $-2^k$个原物品的新物品若干个（k是满足$2^k\leqslant$ si的最大k），新物品可以组合成`[0, si]`内所有整数个原物品，从而替代原物品，并且数量会更少。

```
// cnt统计n件每件si个的原物品全部生成等价的每件1个的新物品之后新物品的件数，初始化为0

for (int i = 1; i <= n; i++) {
    // 获得vi、wi、si
    for (int j = 1; j <= si; j *= 2) {
        si -= j;
        v[cnt] = j * vi;
        w[cnt] = j * wi;
        cnt++;
    }
    if (si > 0) {
        v[cnt] = si * vi;
        w[cnt] = si * wi;
        cnt++;
    }
}
```

从而，n件物品每件si个的多重背包问题转化为cnt件物品每件1个的0/1背包问题。

```
// 原子集合初始化：f[j] = 0 (0<=j<=m)，在前0个物品中选、体积和<=j的所有选法的最大价值可以直接得出为0

for (int i = 1; i <= cnt; i++)
    for (int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);

// 最终结果：f[m]
```

---

<script type="text/javascript" src="/include/tail.js"></script>
