---
title: 完全背包
---

# 完全背包

<script type="text/javascript" src="/include/head.js"></script>

现有n件物品，每件物品有无穷个，物品i的体积为v[i]，物品i的价值为w[i]，要装入容量为m的背包中，求背包可装入的最大价值

## 动态规划设计

用集合的方法分析动态规划，动态规划所要求解的是大集合的属性，大集合可以通过划分成为若干较小集合，以此类推缩小到原子集合，原子集合属性就可以直接得出

动态规划需要定义状态表示，即集合的定义、要求解的集合属性的定义

动态规划需要推导状态计算，即大集合的划分方法、原子集合的属性值

### 状态表示

完全背包问题的集合及其属性定义如下

$$
\left\{
\begin{aligned}
&\text{集合}:\text{在前i个物品中选，体积和}\leqslant j\text{的所有选法集合}\\
&\text{属性}:f(i, j)\text{记录集合中所有选法的最大价值这一属性}
\end{aligned}
\right.
$$

最终要求解的是$f(n, m)$

### 状态计算

完全背包问题的原子集合（在前i个物品中选、体积和$\leqslant 0$的所有选法）的属性值可以直接得出为0

大集合i通过物品i的选不选、选多少划分为小集合i-1，以此类推可以缩小到原子集合

$$
f(i, j) = max
\left\{
\begin{aligned}
&f(i-1, j)&&\text{(不选物品i)}\\
&f(i-1, j-k*v[i])+k*w[i]&&\text{(选k个物品i)}
\end{aligned}
\right.
$$

其中，$i-1 \geqslant 0$、$j-k*v[i] \geqslant 0$

## 滚动数组实现

大集合i只会划分为小集合i-1，因此可以将数组f由二维简化为一维，每轮循环中，f数组更新前存储的是小集合i-1属性，更新后存储的是大集合i属性

f[j]表示体积和$\leqslant j$的所有选法的最大价值，初始化为全0

```
for (int i = 0; i < n; i++)
    for (int j = m; j >= 0; j--)
        for (int k = 1; k*v[i] <= j; k++)
            f[j] = max(f[j], f[j - k*v[i]] + k*w[i]);
```

j从大到小循环，可以确保f[j - k*v[i]]是未更新前的值，是小集合i-1的属性

## 优化

$$
\because
\left\{
\begin{aligned}
&f(i, j) = max\{f(i-1, j), f(i-1, j-v[i])+w[i], f(i-1, j-2*v[i])+2*w[i], ...\}\\
&f(i, j-v[i]) = max\{f(i-1, j-v[i]), f(i-1, j-2*v[i])+w[i], ...\}
\end{aligned}
\right.
$$

$$\therefore f(i, j) = max\{f(i-1, j), f(i, j-v[i])+w[i]\}$$

那么，j从小到大循环，可以确保f[j - v[i]]是被更新后的值，是大集合i的属性

```
for (int i = 0; i < n; i++)
    for (int j = v[i]; j <= m; j++)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```

---

<script type="text/javascript" src="/include/tail.js"></script>
