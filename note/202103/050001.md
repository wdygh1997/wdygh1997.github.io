---
title: 树和图的存储结构
---

# 树和图的存储结构

<script type="text/javascript" src="/include/head.js"></script>

## 图

按照边和顶点的个数（边数m，顶点数n），图可以分为4种情况（以a为度量标准），4种情况又可以归为2大类：

(1)稀疏图

m、n均与a相当；m、n均与$a^2$相当；n与$a^2$相当而m与a相当；

空间复杂度，邻接链表优于邻接矩阵。

(2)稠密图

m与$a^2$相当而n与a相当。

空间复杂度，邻接矩阵优于邻接链表。

### 邻接链表

顶点个数为n，边个数为m；

`head[i]`存储顶点i的邻接链表的首指针，`next[j]`存储链表结点j的next指针，`point[j]`存储边j的指向顶点的编号，d表示数组已用位的下一位；

```
int head[n], next[m], point[m], d = 0;

memset(head, -1, sizeof(head));
```

如果要存储权值，可用`node[i]`存储顶点i的权值，`edge[j]`存储边j的权值；

```
int node[n], edge[m];
```

添加一条a到b的边：

```
point[d] = b;
next[d] = head[a];
head[a] = d++;
```

### 邻接矩阵

顶点个数为n；

`graph[i][j]`存储顶点i到顶点j的边的权值，权值为正无穷大表示不可达；

```
int graph[n][n];

memset(graph, 0x3f, sizeof(graph));
for (int i = 0; i < n; i++) graph[i][i] = 0;
```

如果要存储顶点权值，可用`node[i]`存储顶点i的权值；

```
int node[n];
```

## 边结构体数组

用在一些特殊题型中。

顶点个数为n，边个数为m；

`graph[i]`存储边i，a为边起点，b为边终点，w为边权；

```
struct edge {
    int a, b, w;
}graph[m];
```

## 树

树可以和图使用相同的存储方法，除此之外还有一些特有的存储方法。

### k叉树的二维数组存储

k叉树孩子个数固定为k个（比如二叉树），使用二维数组tree存储树，`tree[i][j]`存储结点i的第j个孩子的编号；

```
int tree[n][k];
```

如果要存储权值，可用`node[i]`存储结点i的权值，`edge[i][j]`存储结点i到结点`tree[i][j]`的边的权值；

```
int node[n], edge[n][k];
```

### 完全二叉树的顺序存储

结点编号从1开始，`tree[1...n]`中的`tree[i]`存储结点i的权值，`tree[0]`空缺；

若2i $\leqslant$ n，结点i有左子结点为2i，若2i+1 $\leqslant$ n，结点i有右子结点为2i+1；

若i/2 $\geqslant$ 1，结点i有父结点为i/2；

```
int tree[n+1];
```

如果要存储边权值，可用`edge[i]`存储结点i的父结点i/2到结点i的边的权值，结点0和1没有父结点，`edge[0]`、`edge[1]`空缺；

```
int edge[n+1];
```

注解：

(1)完全二叉树之所以结点编号从1开始，一是子结点和父结点的编号的计算公式方便记忆，二是可以用i/2 $\geqslant$ 1来判断有父结点，与判断是否具有子结点的方式十分相似，如果编号从0开始却不能用(i-1)/2 $\geqslant$ 0来判断。

---

<script type="text/javascript" src="/include/tail.js"></script>
