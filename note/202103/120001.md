---
title: 树和图的遍历
---

# 树和图的遍历

<script type="text/javascript" src="/include/head.js"></script>

根据<a href="https://www.dywan.xyz/note/202103/150003">枚举</a>一文中的分析，我们知道对状态空间的枚举不需要考虑自顶向下还是自底向上的问题，但是对于数据空间的遍历，还是有需要区分一下这两种情况。

## 深度优先

(1)访问操作自身

```
void DFS(int x) {
    if (x到达递归边界 || 满足剪枝条件) return;

    // 在此处对x进行先序访问和更新操作

    for (遍历x的所有可能后继y) {
        if (y到达递归边界 || 满足剪枝条件) continue;

        DFS(y);
    }

    // 后序访问和还原现场
}

DFS(s); // 调用DFS，从s结点开始遍历
```

注解：

(1)关于两种剪枝条件位置、两种递归边界位置及其区别可以参考<a href="https://www.dywan.xyz/note/202103/150003">枚举</a>。

(2)对树和图的遍历一般都需要访问和操作根结点/源结点，所以一般在扩展后继之前进行访问和操作（当然也可以在扩展后继之后，注意补上对源结点/根结点的访问和操作，这种一般是访问和操作时需要用到前驱的信息）。

## 广度优先

```
queue<int> q;
q.push(s); // 从s结点开始遍历

while (!q.empty()) {
    auto t = q.front();
    q.pop();

    if (t到达循环边界 || 满足限界条件) continue;

    // 在此处对t进行层序访问和更新操作
    
    for (遍历t的所有可能后继y) {
        if (y到达递归边界 || 满足剪枝条件) continue;

        q.push(y);
    }
}
```

注解：

(1)关于两种剪枝条件位置、两种递归边界位置及其区别可以参考<a href="https://www.dywan.xyz/note/202103/150002">宽度优先遍历</a>。

(2)对树和图的遍历一般都需要访问和操作根结点/源结点，所以一般在出队之后（扩展后继之前）进行访问和操作（当然也可以在扩展后继之后，注意补上对源结点/根结点的访问和操作，这种一般是访问和操作时需要用到前驱的信息）。

---

<script type="text/javascript" src="/include/tail.js"></script>
