---
title: 宽度优先搜索
---

# 宽度优先搜索

<script type="text/javascript" src="/include/head.js"></script>

宽度优先搜索需要借助队列，假设从s开始搜索。

按照进行访问和操作的位置可以分为两种情况。

(1)入队之前（扩展后继之后）访问和操作

```
queue<int> q;
// 在此处对s进行访问
q.push(s); // 从s结点开始搜索

while (!q.empty()) {
    auto t = q.front();
    q.pop();
    
    for (遍历t的所有可能后继y) {
        if (y到达循环边界 || 满足限界条件) continue;

        // 在此处对y进行层序访问和更新操作
        q.push(y);
    }
}
```

(2)出队之后（扩展后继之前）访问和操作

```
queue<int> q;
q.push(s); // 从s结点开始搜索

while (!q.empty()) {
    auto t = q.front();
    q.pop();

    // 在此处对t进行层序访问和更新操作
    
    for (遍历t的所有可能后继y) {
        if (y到达循环边界 || 满足限界条件) continue;

        q.push(y);
    }
}
```

注解：

(1)在两个地方进行访问和操作本质上没有区别；

如果是在入队之前（扩展后继之后），遍历不到根结点/源结点，要事先对其单独进行访问和操作，不过好处是，这个时候知道后继y的前驱就是x，如果对y进行操作时需要用到前驱x的信息，最好是在入队之前（扩展后继之后）进行；

访问和操作在出队之后（扩展后继之前）可以遍历到根结点/源结点，但是也就不能得到前驱信息了。

(2)BFS的限界和循环边界一般就放在扩展结点之后了，并且限界后继时还可以看到前驱结点，如果要利用前驱结点的信息进行限界的话。

---

<script type="text/javascript" src="/include/tail.js"></script>
