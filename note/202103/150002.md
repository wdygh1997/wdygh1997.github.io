---
title: 宽度优先搜索
---

# 宽度优先搜索

<script type="text/javascript" src="/include/head.js"></script>

宽度优先搜索需要借助队列，假设从s开始搜索。

按照进行访问和操作的位置可以分为两种情况。

(1)入队之前（扩展后继之后）访问和操作

```
queue<int> q;
// 在此处对s进行层序访问和更新操作
q.push(s); // 从s结点开始搜索

while (!q.empty()) {
    auto t = q.front();
    q.pop();

    if (t到达循环边界 || 满足限界条件) continue;
    
    for (遍历t的所有可能后继y) {
        if (y到达循环边界 || 满足限界条件) continue;

        // 在此处对y进行层序访问和更新操作
        q.push(y);
    }
}
```

(2)出队之后（扩展后继之前）访问和操作

```
queue<int> q;
q.push(s); // 从s结点开始搜索

while (!q.empty()) {
    auto t = q.front();
    q.pop();

    if (t到达循环边界 || 满足限界条件) continue;

    // 在此处对t进行层序访问和更新操作
    
    for (遍历t的所有可能后继y) {
        if (y到达循环边界 || 满足限界条件) continue;

        q.push(y);
    }
}
```

注解：BFS算法框架中，判断限界条件、判断循环边界、进行访问操作都有两种位置，总结起来区别就是，在扩展后继之前的限界条件/循环边界/访问操作是针对自身的，在扩展后继之后的限界条件/循环边界/访问操作是针对后继的：

(1)对于访问操作的两种位置，如果采用针对后继的访问操作，在整个循环过程中是访问不到根结点的，如果需要访问根结点只能在循环外部进行，而采用针对自身的访问操作，在循环过程中能够访问到根结点。不过如果状态空间是森林型结构，构造一个无意义结点作为几个树型结构的父结点，那么整个状态空间就变成了一个树型结构，并且不需要访问根结点，则采用针对后继的访问操作更为方便。

(2)限界条件有两种位置，限界后继比限界自身的优点是，限界后继时还可以看到前驱结点，如果要利用前驱结点的信息进行剪枝，就必须使用限界后继。

(3)循环边界有两种位置，如果是在扩展后继之前，循环会进入空指针（即x已经在边界之外），如果是在扩展后继之后，循环不会进入空指针（y不会到边界之外）。

---

<script type="text/javascript" src="/include/tail.js"></script>
