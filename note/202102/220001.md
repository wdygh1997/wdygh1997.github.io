---
title: 双指针
---

# 双指针

<script type="text/javascript" src="/include/head.js"></script>

## 滑动窗口

双指针维护一个滑动窗口，r指针遍历序列一遍，l指针始终在r指针左侧且不会后退，因此复杂度为$O(n)$。

```
for (int r = 0, l = 0; r < n; r++)
{
    // r右移扩大窗口后的操作
    while (l < r && check(l, r)) {
        // l右移缩小窗口后的操作
        l++;
    }
    // 窗口变为(l, r)后的操作
}
```

## 原地操作

(1)原地修改

原地修改通常是序列需要删除掉一些不需要的元素，用需要保留的元素去覆盖不需要保留的元素。

l指针始终指向当前需要被修改的位置，r指针遍历序列寻找用来修改a[l]的元素，找到后a[l] = a[r]，复杂度为$O(n)$。

(2)原地交换

原地交换通常是序列的两个部分分别满足不同的性质，用两个指针分别遍历两个部分，将不满足性质的元素交换到另一部分去。

l指针和r指针分别寻找两个要交换的元素，找到后swap(a[l], a[r])，复杂度为$O(n)$。

## 快慢指针

适用于一些特定题型。

例如判断链表是否有环等。

## 对撞指针

适用于一些特定题型。

例如在有序序列中寻找两个数的和为定值，使用两个指针分别指向开头向后遍历，指向结尾向前遍历，从而使得两个指针指向的数字之和稳定在所求的和定值附近，复杂度为$O(n)$。

---

<script type="text/javascript" src="/include/tail.js"></script>
