---
title: dp的原理与实现
---

# dp的原理与实现

<script type="text/javascript" src="/include/head.js"></script>

## dp的原理

我们尝试从集合的角度来解释dp。
一个问题有很多种可能情况，将这些所有的可能情况组成一个集合，问题的解就是这个集合的一个属性。
总集合的属性（该问题的解）没办法一下子得到，我们选择将其划分为小一级的集合，
使得大一级的集合属性可以由小一级的集合属性直接推导出来。
这样层层推导，直到最小级集合全部变为原子集合，原子集合的属性可以直接得到。
如果上述集合划分方案可行，我们在求解总集合的属性时，就可以从原子集合的属性出发，层层向上推导直到求出总集合属性。

一个问题要能够使用dp求解必须具备三个性质：子问题重叠性、无后效性、最优子结构性。

### 子问题重叠性

dp的集合划分最终会形成一个“树型结构”（并不是严格的树）。
分析暴力搜索的搜索树可以发现，其中存在大量重复结点（每个结点对应一次计算），从而导致大量重复计算。
dp效率较高的原因在于，dp的“树型结构”将重复结点合并为一个（也就是说，可能存在某些结点有多个父结点，所以并不是严格的树，只是“树型结构”），从而避免重复计算。
换言之，如果一个问题没有子问题重叠性，那么dp也就失去了优化作用。

### 无后效性

首先我们知道，过去的状态&决策决定了当前阶段的状态，那么，无后效性指的是：
当前的状态确定之后，未来的决策&状态取决于且只取决于当前的状态。
无后效性包含两层含义：
一是只有当前的状态在影响着未来的决策&状态，过去的状态&决策不会影响未来的决策&状态（即“只取决于”）；
二是未来的决策&状态不会影响当前的状态（即“取决于”，不能反推）。
换句话说，无后效性描述的是一种当前对未来的单向唯一决定关系，
既不会过去影响将来（唯一），也不会将来改变当前（单向）。

有了无后效性，我们可以放心地使用已知集合的属性求解后面更大集合的属性，
既不用担心集合的扩大导致已知集合的属性发生改变，
也不用担心更大集合属性的求解会用到除了已知集合属性之外的更多信息。

### 最优子结构性

最优子结构性是指：子问题的最优解能推出更大问题的最优解，更大问题的最优解包含其子问题的最优解。

综合来看，无后效性和最优子结构性要保证的是：
既不能让集合的扩大导致已知集合的最优值发生改变，
也不能让更大集合属性的求解要用到除了已知集合最优值之外的更多信息。

## dp的实现

### dp的设计

dp的设计包括两个步骤：状态表示和状态计算。

设计状态表示时需要考虑的是：问题如何用集合来表达，问题的解如何用集合的属性来表达；设计状态计算时需要考虑的是：大一级集合的属性如何由小一级集合的属性推导出来，原子集合的属性是多少。

总而言之，dp的设计是要根据题意设计出一个满足无后效性和最优子结构性的集合及其属性。

dp的设计有两种方式（也就是说，问题用集合来表达有两种方式），一种是将问题用一个集合表达，dp的集合划分形成树型结构，总集合成为树型结构的根结点，问题的解就是这一个集合的属性值（如：数塔问题），另一种是将问题拆分成多个集合来表达，dp的集合划分形成树形结构（或者是森林型结构），其中最大的集合成为树型结构的根结点（或者是其中最大的几个集合成为森林型结构的几个根结点），也是其余集合的祖先结点，问题的解就是这些集合的属性值中最优的那一个（如：数岭问题）。

### dp的递推实现

dp的实现也有两种方式，即递推（自底向上）和递归（自顶向下）。

dp的递推实现包括三个要素：阶段、状态和决策。
具体来讲，应该是按照自底向上的顺序遍历所有阶段，每个阶段遍历其中的所有状态，
利用过去阶段的状态计算当前阶段的状态（即为决策）。

#### 数塔问题

```
A[1][1]
A[2][1] A[2][2]
A[3][1] A[3][2] A[3][3]
......
A[n][1] A[n][2] ...... A[n][n]
```

从顶层出发，每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

将问题的解用从顶层结点到底层结点的所有路径的最大的数字和这一集合属性来表达，dp的集合划分形成树型结构。

原子集合属性（由底层结点`A[n][j]`，1 $\leqslant$ j $\leqslant$ n，单个结点组成的路径的最大数字和）可以直接得出为`A[n][j]`。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[i][j] = max
\left\{
\begin{aligned}
&f[i+1][j]+A[i][j]&&\text{(移动到左下方结点)}\\
&f[i+1][j+1]+A[i][j]&&\text{(移动到右下方结点)}
\end{aligned}
\right.
$$

```
// 原子集合初始化：f[n][j] = A[n][j] (1<=j<=n)

for (int i = n-1; i >= 1; i--)
    for (int j = 1; j <= i; j++)
        f[i][j] = max(f[i+1][j], f[i+1][j+1]) + A[i][j];

// 最终结果：f[1][1]
```

数塔问题最能体现动态规划的特点，这个数塔本身就是一个动态规划中所说的树型结构。

### dp的递归实现

dp的递归实现也叫记忆化搜索。实现时的注意点有：

1、递归函数与状态有对应关系，每个递归函数实现了转移到其对应的状态的推导式；

2、由于dp是树型结构而不是严格的树，因此会出现多次递归到同一结点的情况，所以首先将所有状态标记为未计算，递归中遇到已经计算的结点直接返回其状态值（这就是记忆化搜索名称的由来）；

3、与第2点相同的原因，原子集合的初始化只在递归中先序访问的位置进行，不能预先进行（因为标记未计算在这里完成，使得原子集合的初始化无法在该位置进行）；

4、主程序需要调用一下树型结构的根结点（森林型结构的所有根结点）处的dp函数，才能使状态被计算出来；根结点会难以辨别，实际中一般是直接将全部结点处的dp函数全部调用一遍，不会增加运算量。

#### 数岭问题

```
A[1][1] A[1][2] ...... A[1][n]
A[2][1] A[2][2] ...... A[2][n]
......
A[n][1] A[n][2] ...... A[m][n]
```

`A[x][y]`表示该点的高度。从某点出发，每次可以向上/下/左/右移动一个点（前提是去往点的高度低于当前点的高度），可以从任意点出发，要求移动路径的最大长度。

将问题用`m*n`个集合属性来表达，即从`A[x][y]`（1 $\leqslant$ x $\leqslant$ m，1 $\leqslant$ y $\leqslant$ n）出发的最长移动长度，这`m*n`个最大长度的最大值就是问题的解，dp的集合划分形成森林型结构，
`A[x][y]`（1 $\leqslant$ x $\leqslant$ m，1 $\leqslant$ y $\leqslant$ n）中位于峰顶的几个点的集合成为森林型结构的根结点，也是其他集合的祖先结点。

原子集合属性（从`A[x][y]`，1 $\leqslant$ x $\leqslant$ m，1 $\leqslant$ y $\leqslant$ n，出发没有后继点的路径的最大长度）可以直接得出为1。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[x][y] = max
\left\{
\begin{aligned}
&1&&\text{(A[x][y]没有能前往的点)}\\
&f[a][b]+1, [a][b]\in\{[x-1][y], [x+1][y], [x][y-1], [x][y+1]\}&&\text{(A[x][y]前往的点为A[a][b])}
\end{aligned}
\right.
$$

本题的技巧：

1、在二维矩阵`A[1...m][1...n]`外添加一圈表示边界的标记（这里采用-1），可以便于判断出界；

2、定义`dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1}`，可以便于循环遍历上/下/左/右的四个点。

```
// 标记未计算：f[x][y] = -1 (1<=x<=m, 1<=y<=n)

int dp(int x, int y) {
    if (f[x][y] != -1)
        return f[x][y];

    f[x][y] = 1;  // 原子集合初始化

    for (int i = 0; i < 4; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (A[a][b] != -1 && A[a][b] < A[x][y])
            f[x][y] = max(f[x][y], dp(x, y) + 1);
    }

    return f[x][y];
}

for (int x = 1; x <= m; x++)
    for (int y = 1; y <= n; y++)
        dp(x, y);

// 最终结果：max(f[x][y]) (1<=x<=m, 1<=y<=n)
```

### dp实现的总结

前面提到，dp的设计有两种方式（树型结构和森林型结构），dp的实现有两种方式（递推和递归），这两者是相互独立的，也就是说dp一共有2 $\times$ 2 = 4种类型。

另外，定义状态数组f时，即使没有显式初始化也会有初值存在（由C/C++特性决定），我们需要保证这个初值不会影响dp后续计算（例如：要计算的属性为max，初始化为较小值不会影响后续计算），有两种情况可以将全部状态都初始化为原子集合状态值：

1、原子集合可能无法直接获得（需要一套判断逻辑才能判断），如果，即使将非原子集合对应的状态初始化为原子集合对应的状态，也不会影响dp后续的计算的话，那么就可以将所有状态全部初始化为原子集合状态值，从而简化初始化的过程。

2、在数岭问题中，如果`A[x][y]`没有能前往的点，推导式是`f[x][y] = 1`，不过实际代码中我们是`f[x][y] = max(f[x][y], dp(x, y) + 1)`，而不是`f[x][y] = max(1, dp(x, y) + 1)`，这是因为推导式中有一个定值（也就是本题中1这个值），我们用这个定值来初始化了所有状态，从而导致状态推导发生了变化。所以，在推导式有定值的时候，就可以考虑用这个定值来初始化所有状态，从而简化初始化的过程。

---

<script type="text/javascript" src="/include/tail.js"></script>
