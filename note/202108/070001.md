---
title: 线性动态规划
---

# 线性动态规划

<script type="text/javascript" src="/include/head.js"></script>

## 动态规划原理

我们尝试从集合的角度来解释动态规划。
题目中给出的问题有很多种可能情况，将这些所有的可能情况构成一个集合，问题的解就是这个集合一个属性。
总集合的属性（问题的解）没办法一下子得到，我们选择将其划分为小一级的集合，
使得大一级的集合属性可以由小一级的集合属性直接推导出来。
这样层层推导，直到最小级集合全部变为原子集合，原子集合的属性可以直接得到。
如果上述集合划分方案可行，我们在求解总集合的属性时，就可以从原子集合的属性出发，层层向上推导直到求出总集合属性。

一个问题要能够使用动态规划求解必须具备三个性质：子问题重叠性、无后效性、最优子结构性。

### 子问题重叠性

动态规划的集合划分最终会形成一个“树型结构”（并不是严格的树）。
分析暴力搜索的搜索树可以发现，其中存在大量重复结点（每个结点对应一次计算），从而导致大量重复计算。
动态规划效率较高的原因在于，动态规划的“树型结构”将重复结点合并为一个（也就是说，可能存在结点有多个父结点，所以并不是严格的树，只是“树型结构”），从而避免重复计算。
换言之，如果一个问题没有子问题重叠性，那么动态规划也就失去了优化作用。

### 无后效性

首先我们知道，过去的状态&决策决定了当前阶段的状态，那么，无后效性指的是：
当前的状态确定之后，未来的决策&状态取决于且只取决于当前的状态。
无后效性包含两层含义：
一是只有当前的状态在影响着未来的决策&状态，过去的状态&决策不会影响未来的决策&状态（即“只取决于”）；
二是未来的决策&状态不会影响当前的状态（即“取决于”，不能反推）。
换句话说，无后效性描述的是一种当前对未来的单向唯一决定关系，
既不会过去影响将来（唯一），也不会将来改变当前（单向）。

有了无后效性，我们可以放心地使用已知集合的属性求解后面更大集合的属性，
既不用担心集合的扩大导致已知集合的属性发生改变，
也不用担心更大集合属性的求解会用到除了已知集合属性之外的更多信息。

### 最优子结构性

最优子结构性是指：子问题的最优解能推出更大问题的最优解，更大问题的最优解包含其子问题的最优解。

综合来看，无后效性和最优子结构性要保证的是：
既不能让集合的扩大导致已知集合的最优值发生改变，
也不能让更大集合属性的求解要用到除了已知集合最优值之外的更多信息。

## 动态规划设计与实现

### 动态规划的设计

动态规划的设计包括两个步骤：状态表示和状态计算。

设计状态表示时需要考虑的是：问题如何用集合来表达，问题的解如何用集合的属性来表达；设计状态计算时需要考虑的是：大一级集合的属性如何由小一级集合的属性推导出来，原子集合的属性是多少。

总而言之，动态规划的设计是要根据题意设计出一个满足无后效性和最优子结构性的集合及其属性。

### 动态规划的实现

动态规划的实现包括三个要素：阶段、状态和决策。
具体来讲，应该是按照自底向上的顺序遍历所有阶段，每个阶段遍历其中的所有状态，
利用过去阶段的状态计算当前阶段的状态（即为决策）。

## 线性dp

线性动态规划（简称线性规划）是指，目标函数为特定变量的线性函数，约束条件是这些变量的线性等式或不等式，求解目标函数的最优值的问题（所谓线性，即只包含加法和数乘两种运算）。

换句话说，如果一个动态规划满足：由过去状态计算当前状态的推导函数是线性函数，并且推导时采用的决策条件是线性等式或不等式，那么这种动态规划就是线性动态规划。

### 数塔问题

```
A[1][1]
A[2][1] A[2][2]
A[3][1] A[3][2] A[3][3]
......
A[n][1] A[n][2] ...... A[n][n]
```

从顶层出发，每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
// 原子集合初始化：f[n][j] = A[n][j] (1<=j<=n)

for (int i = n-1; i >= 1; i--)
    for (int j = 1; j <= i; j++)
        f[i][j] = max(f[i+1][j], f[i+1][j+1]) + A[i][j];

// 最终结果：f[1][1]
```

数塔问题最能体现动态规划的特点，这个数塔本身就是一个动态规划中所说的树型结构。

### 线性dp的设计

线性dp中，问题用集合来表达有两种方式，一种是将问题用一个集合表达，成为动态规划树型结构的根结点，问题的解就是这一个集合的属性值（最长公共子序列、最短编辑距离），另一种是将问题拆分成多个集合来表达，其中最大的集合成为动态规划树型结构的根结点，也是其余集合的祖先结点，问题的解就是这些集合的属性值中最优的那一个（最大连续子序列和、最长有序子序列）。

### 最大连续子序列和

```
A[1] A[2] A[3] ...... A[n]
```

求该序列的连续子序列的和的最大值。

将问题用n个集合属性来表达，即以A[i]（1 $\leqslant$ i $\leqslant$ n）结尾的连续子序列的最大和，
这n个最大和的最大值就是问题的解，A[n]集合成为树型结构的根结点，也是集合A[i]（1 $\leqslant$ i $\leqslant$ n-1）的祖先结点。

原子集合属性（以A[1]结尾的连续子序列最大和）可以直接得出为A[1]。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[i] = max
\left\{
\begin{aligned}
&A[i]&&\text{(A[i]不与以A[i-1]结尾的连续子序列组成新的连续子序列)}\\
&f[i-1]+A[i]&&\text{(A[i]与以A[i-1]结尾连续子序列组成新的连续子序列)}
\end{aligned}
\right.
$$

```
// 原子集合初始化：f[1] = A[1]

for (int i = 2; i <= n; i++)
    f[i] = max(A[i], f[i-1] + A[i]);

// 最终结果：max(f[i]) (1<=i<=n)
```

### 最长有序子序列

```
A[1] A[2] A[3] ...... A[n]
```

求该序列的有序子序列的最大长度（有序可以是不下降，上升，不上升，下降，这里以上升为例）。

将问题用n个集合属性来表达，即以A[i]（1 $\leqslant$ i $\leqslant$ n）结尾的上升子序列的最大长度，
这n个最大长度的最大值就是问题的解，A[n]集合成为树型结构的根结点，也是集合A[i]（1 $\leqslant$ i $\leqslant$ n-1）的祖先结点。

原子集合属性（以A[i]，1 $\leqslant$ i $\leqslant$ n，结尾的没有前序元素的上升子序列的最大长度）可以直接得出为1。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[i] = max
\left\{
\begin{aligned}
&1&&\text{(A[i]没有前序元素)}\\
&f[j]+1,1\leqslant j<i&&\text{(A[i]前序元素为A[j])}
\end{aligned}
\right.
$$

```
// 原子集合初始化：f[i] = 1 (1<=i<=n)

for (int i = 1; i <= n; i++)
    for (int j = 1; j < i; j++)
        if (A[i] > A[j])
            f[i] = max(f[i], f[j] + 1);

// 最终结果：max(f[i]) (1<=i<=n)
```

#### 贪心优化

最长有序子序列问题还可以优化，不过不再是动态规划的范畴，详见<a href="https://www.dywan.xyz/note/202108/120001">贪心</a>一文。

### 最长公共子序列

```
A[1] A[2] A[3] ...... A[m]
B[1] B[2] B[3] ...... B[n]
```

求两个序列的公共子序列的最大长度。

将问题的解用序列A前m个元素序列和序列B前n个元素序列的所有公共子序列的最大长度这一集合属性来表达。

原子集合属性（序列A前0个元素序列和序列B前j个元素序列，1 $\leqslant$ j $\leqslant$ n，的所有公共子序列最大长度、序列A前i个元素序列，1 $\leqslant$ i $\leqslant$ m，和序列B前0个元素序列的所有公共子序列最大长度）可以直接得出为0。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[i][j] = max
\left\{
\begin{aligned}
&f[i-1][j-1]+1&&\text{(选A[i]和B[j]，即A[i]==B[j])}\\
&max\{f[i-1][j], f[i][j-1]\}&&\text{(不选A[i]或不选B[j]，即A[i]!=B[j])}
\end{aligned}
\right.
$$

```
// 原子集合初始化：f[i][1] = f[1][j] = 0 (1<=i<=m,1<=j<=n)

for (int i = 1; i <= m; i++)
    for (int j = 1; j <= n; j++)
        if (A[i] == A[j])
            f[i][j] = f[i-1][j-1] + 1;
        else
            f[i][j] = max(f[i-1][j], f[i][j-1]);

// 最终结果：f[m][n]
```

### 最短编辑距离

```
A[1] A[2] A[3] ...... A[m]
B[1] B[2] B[3] ...... B[n]
```

求将序列A变为序列B的最少编辑步数（编辑操作包括插入、删除和修改三种）。

将问题的解用将序列A前m个元素序列编辑成序列B前n个元素序列的最少步数这一集合属性来表达。

原子集合有两种：第一种（将序列A前i个元素序列，1 $\leqslant$ i $\leqslant$ m，编辑成序列B前0个元素序列的最少步数）属性可以直接得出为i；第二种（序列A前0个元素序列编辑成序列B前j个元素序列，1 $\leqslant$ j $\leqslant$ n，的最少步数）属性可以直接得出为j。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[i][j] = min
\left\{
\begin{aligned}
&min\{f[i-1][j]+1, f[i][j-1]+1\}&&\text{(将A[i]删除或插入)}\\
&f[i-1][j-1]&&\text{(A[i]!=B[j]，将A[i]修改为B[j])}\\
&f[i-1][j-1]+1&&\text{(A[i]==B[j]，A[i]不需要修改)}
\end{aligned}
\right.
$$

```
// 原子集合初始化：f[i][1] = i (1<=i<=m), f[1][j] = j (1<=j<=n)

for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        f[i][j] = min(f[i-1][j]+1, f[i][j-1]+1);
        if (A[i] == B[j])
            f[i][j] = min(f[i][j], f[i-1][j-1]);
        else
            f[i][j] = min(f[i][j], f[i-1][j-1]+1);
    }
}

// 最终结果：f[m][n]
```

---

<script type="text/javascript" src="/include/tail.js"></script>
