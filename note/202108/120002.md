---
title: 区间动态规划
---

# 区间动态规划

<script type="text/javascript" src="/include/head.js"></script>

动态规划的理论以及线性dp已经在<a href="https://www.dywan.xyz/note/202108/070001">线性动态规划</a>一文中详细阐述。区间动态规划问题也属于线性dp，将区间长度作为阶段，将区间左右端点作为状态，在实现时特别强调“先阶段、后状态、再决策”的循环顺序。

## 最优合并问题

```
A[1] A[2] A[3] ...... A[n]
```

每次只能合并相邻的两个数，合并的代价为这两个数之和，最终要将所有数合并成一个，合并顺序的不同会导致总的代价不同，求合并的最小代价。

将问题的解用将A[1]到A[n]的数字合并为一个的最小代价这一集合属性来表达。

原子集合属性（将A[i]，1 $\leqslant$ i $\leqslant$ n，与A[i]自己合并的最小代价）可以直接得出为0。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[l][r] = min
\left\{
\begin{aligned}
&f[l][k]+f[k+1][r]+\sum_{i=l}^{r}A[i],l\leqslant k<r&&\text{(以k和k+1为界将A[l...r]分为两部分)}
\end{aligned}
\right.
$$

最优合并问题在实现时需要先计算数组A的<a href="https://www.dywan.xyz/note/202102/210001">前缀和</a>数组S，
用以计算$\sum_{i=l}^{r}A[i]$（= S[r] - S[l-1]）。

```
// 原子集合初始化：f[i][i] = 0 (1<=i<=n)

for (int len = 2; len <= n; len++) {
    for (int l = 1; l+len-1 <= n; l++) {
        int r = l+len-1;
        f[l][r] = f[l][l] + f[l+1][r] + S[r] - S[l-1];
        for (int k = l+1; k < r; ++k)
            f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + S[r] - S[l-1]);
    }
}

// 最终结果：f[1][n]
```

---

<script type="text/javascript" src="/include/tail.js"></script>