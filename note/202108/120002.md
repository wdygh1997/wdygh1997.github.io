---
title: 区间dp
---

# 区间dp

<script type="text/javascript" src="/include/head.js"></script>

区间dp通常采用递推方式实现，将区间长度作为阶段，将区间左右端点作为状态，在实现时特别强调“先阶段、后状态、再决策”的循环顺序。

## 最优合并问题

```
A[1] A[2] A[3] ...... A[n]
```

每次只能合并相邻的两个数，合并的代价为这两个数之和，最终要将所有数合并成一个，合并顺序的不同会导致总的代价不同，求合并的最小代价。

将问题的解用将A[1]到A[n]的数字合并为一个的最小代价这一集合属性来表达。

原子集合属性（将A[i]，1 $\leqslant$ i $\leqslant$ n，与A[i]自己合并的最小代价）可以直接得出为0。

小一级集合的属性到大一级集合的属性的推导式为：

$$
f[l][r] = min
\left\{
\begin{aligned}
&f[l][k]+f[k+1][r]+\sum_{i=l}^{r}A[i],l\leqslant k<r&&\text{(以k和k+1为界将A[l...r]分为两部分)}
\end{aligned}
\right.
$$

最优合并问题在实现时需要先计算数组A的<a href="https://www.dywan.xyz/note/202102/210001">前缀和</a>数组S，
用以计算$\sum_{i=l}^{r}A[i]$（= S[r] - S[l-1]）。

```
// 原子集合初始化：f[i][i] = 0 (1<=i<=n)

for (int len = 2; len <= n; len++) {  // 阶段：区间长度
    for (int l = 1; l+len-1 <= n; l++) {  // 状态：左端点
        int r = l+len-1;  // 状态：右端点
        f[l][r] = f[l][l] + f[l+1][r] + S[r] - S[l-1];  // 决策
        for (int k = l+1; k < r; ++k)  // 决策
            f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + S[r] - S[l-1]);  // 决策
    }
}

// 最终结果：f[1][n]
```

## 阶段、状态与决策

动态规划实现时，务必分清阶段、状态和决策、三者应该按照从外到内的顺序依次循环。

具体来讲，应该是按照自底向上的顺序遍历所有阶段，每个阶段遍历其中的所有状态， 利用过去阶段的状态计算当前阶段的状态（即为决策）。

---

<script type="text/javascript" src="/include/tail.js"></script>